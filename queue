# Queue Client - Wallet Queue Client

## ğŸ“‹ Má»¥c Lá»¥c

1. [Tá»•ng Quan](#tá»•ng-quan)
2. [Kiáº¿n TrÃºc](#kiáº¿n-trÃºc)
3. [CÃ¡c Components](#cÃ¡c-components)
4. [CÃ¡ch Hoáº¡t Äá»™ng](#cÃ¡ch-hoáº¡t-Ä‘á»™ng)
5. [CÃ¡ch Sá»­ Dá»¥ng](#cÃ¡ch-sá»­-dá»¥ng)
6. [Flow Xá»­ LÃ½](#flow-xá»­-lÃ½)
7. [Cáº¥u HÃ¬nh](#cáº¥u-hÃ¬nh)
8. [TÃ­nh NÄƒng](#tÃ­nh-nÄƒng)
9. [Best Practices](#best-practices)
10. [Troubleshooting](#troubleshooting)

---

## ğŸ¯ Tá»•ng Quan

File `client.go` lÃ  **Queue Client** chuyÃªn dá»¥ng cho wallet module, cung cáº¥p typed API Ä‘á»ƒ enqueue credit vÃ  debit jobs vÃ o queue system.

### Má»¥c ÄÃ­ch

- âœ… Cung cáº¥p **typed API** cho wallet operations (khÃ´ng pháº£i generic)
- âœ… **Abstraction layer** giá»¯a handlers vÃ  queue implementation
- âœ… Há»— trá»£ **multiple queue providers** (Redis/Asynq, RabbitMQ, Kafka, NATS)
- âœ… Tá»± Ä‘á»™ng serialize payload vÃ  xá»­ lÃ½ errors
- âœ… Xá»­ lÃ½ **idempotency** vÃ  duplicate tasks

### Vai TrÃ² Trong Há»‡ Thá»‘ng

```
HTTP Handler â†’ Queue Client â†’ Asynq Queue â†’ Redis â†’ Worker â†’ Business Logic
```

---

## ğŸ—ï¸ Kiáº¿n TrÃºc

### Design Pattern

Sá»­ dá»¥ng **Strategy Pattern** vá»›i interface abstraction:

```go
Queue Interface (contract)
    â†“
Client (delegator)
    â†“
asynqQueue (implementation) â”€â”€â†’ Asynq Library â”€â”€â†’ Redis
unimplementedQueue (placeholders)
```

### Package Structure

```
infra/queue/client/
â””â”€â”€ client.go          # Queue client implementation
```

### Dependencies

- **Asynq**: `github.com/hibiken/asynq` - Redis-based queue library
- **Config**: `ludo-be/infra/config` - Configuration management
- **Queue constants**: `ludo-be/infra/queue` - Job types, queue names

---

## ğŸ”§ CÃ¡c Components

### 1. Queue Interface

```go
type Queue interface {
    Close() error
    EnqueueCredit(ctx context.Context, payload interface{}) error
    EnqueueDebit(ctx context.Context, payload interface{}) error
}
```

**Má»¥c Ä‘Ã­ch:** Äá»‹nh nghÄ©a contract cho táº¥t cáº£ queue implementations

### 2. Client Struct

```go
type Client struct {
    queue Queue  // Concrete implementation
}
```

**Má»¥c Ä‘Ã­ch:** Wrapper Ä‘á»ƒ delegate calls Ä‘áº¿n concrete queue implementation

**Public Methods:**
- `NewClient()` - Factory function
- `EnqueueCredit()` - Enqueue credit job
- `EnqueueDebit()` - Enqueue debit job
- `Close()` - Cleanup resources

### 3. asynqQueue (Implementation)

```go
type asynqQueue struct {
    client *asynq.Client  // Asynq client
}
```

**Má»¥c Ä‘Ã­ch:** Redis/Asynq implementation cá»§a Queue interface

**Features:**
- Táº¡o Asynq client vá»›i Redis connection
- Serialize payload thÃ nh JSON
- Enqueue vá»›i options (retry, timeout, queue name)
- Xá»­ lÃ½ duplicate tasks gracefully

### 4. unimplementedQueue (Placeholder)

```go
type unimplementedQueue struct {
    name string  // Provider name
}
```

**Má»¥c Ä‘Ã­ch:** Placeholder cho cÃ¡c queue providers chÆ°a implement (RabbitMQ, Kafka, NATS)

---

## âš™ï¸ CÃ¡ch Hoáº¡t Äá»™ng

### 1. Khá»Ÿi Táº¡o Client

```go
// Trong wire.go
func provideQueueClient() (*qclient.Client, error) {
    return qclient.NewClient()
}
```

**Process:**
1. Äá»c `QUEUE_PROVIDER` env var (default: "redis")
2. Chá»n implementation dá»±a trÃªn provider
3. Táº¡o Asynq client vá»›i Redis config
4. Tráº£ vá» `*Client` wrapper

**Code Flow:**
```go
NewClient()
  â†“
os.Getenv("QUEUE_PROVIDER")  // "redis" (default)
  â†“
switch provider {
  case "redis":
    newasynqQueue()  // â† Táº¡o Asynq client
      â†“
    asynq.NewClient(redisAddr, password, db)
      â†“
    return &Client{queue: asynqQueue}
}
```

### 2. Enqueue Credit Job

```go
queueClient.EnqueueCredit(ctx, payload)
```

**Internal Process:**
1. Client delegates Ä‘áº¿n `queue.EnqueueCredit()`
2. `asynqQueue` táº¡o Asynq task:
   ```go
   task := asynq.NewTask("wallet:credit", serializedPayload)
   ```
3. Set options:
   - `MaxRetry(3)` - Retry tá»‘i Ä‘a 3 láº§n
   - `Timeout(30s)` - Timeout 30 giÃ¢y
   - `Queue("wallet-credit")` - Queue name
4. Enqueue vÃ o Redis qua Asynq
5. Xá»­ lÃ½ duplicate errors (return nil, khÃ´ng fail)

### 3. Serialization

```go
serializePayload(payload interface{}) []byte
```

- Marshal payload thÃ nh JSON
- Return error payload náº¿u marshal fail
- Äáº£m báº£o payload luÃ´n lÃ  valid JSON

---

## ğŸ“– CÃ¡ch Sá»­ Dá»¥ng

### 1. Khá»Ÿi Táº¡o (Qua Wire)

```go
// Trong cmd/api/wire.go
func provideQueueClient() (*qclient.Client, error) {
    return qclient.NewClient()
}

// Wire tá»± Ä‘á»™ng inject vÃ o WalletHandler
func provideWalletHandler(
    // ...
    queueClient *qclient.Client,  // â† Injected here
    // ...
) *walletHandler.WalletHandler {
    return walletHandler.NewWalletHandler(..., queueClient, ...)
}
```

### 2. Sá»­ Dá»¥ng Trong Handler

```go
// internal/modules/wallet/interfaces/http/handler.go
func (h *WalletHandler) Credit(c *gin.Context) {
    // 1. Parse request
    var dto dtos.CreditBalanceDTO
    c.ShouldBindJSON(&dto)
    
    // 2. Prepare payload
    payload := queue.CreditJobPayload{
        UserID:      dto.UserID,
        Amount:      dto.Amount,
        ReferenceID: dto.ReferenceID,
        Metadata:    dto.Metadata,
    }
    
    // 3. Enqueue job
    if err := h.queueClient.EnqueueCredit(c.Request.Context(), payload); err != nil {
        httpx.GinAbortWithError(c, err)
        return
    }
    
    // 4. Return 202 Accepted
    httpx.GinJSON(c, map[string]string{"status": "enqueued"}, http.StatusAccepted)
}
```

### 3. Payload Structure

#### CreditJobPayload
```go
type CreditJobPayload struct {
    UserID      string                 `json:"user_id"`
    Amount      int64                  `json:"amount"`
    ReferenceID *string                `json:"reference_id,omitempty"`  // Optional: cho idempotency
    Metadata    map[string]interface{} `json:"metadata,omitempty"`      // Optional: thÃ´ng tin bá»• sung
}
```

#### DebitJobPayload
```go
type DebitJobPayload struct {
    UserID      string                 `json:"user_id"`
    Amount      int64                  `json:"amount"`
    ReferenceID *string                `json:"reference_id,omitempty"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

### 4. Error Handling

```go
err := queueClient.EnqueueCredit(ctx, payload)
if err != nil {
    // CÃ³ thá»ƒ lÃ :
    // - Redis connection error
    // - Serialization error (hiáº¿m)
    // - Unknown provider error
    return err
}

// Success: Job Ä‘Ã£ Ä‘Æ°á»£c enqueue vÃ o Redis
// Worker sáº½ xá»­ lÃ½ báº¥t Ä‘á»“ng bá»™
```

---

## ğŸ”„ Flow Xá»­ LÃ½ HoÃ n Chá»‰nh

### Credit Flow

```
1. Client gá»i API: POST /wallet/credit
   â†“
2. WalletHandler.Credit() nháº­n request
   â†“
3. Validate vÃ  parse DTO
   â†“
4. Táº¡o CreditJobPayload
   â†“
5. queueClient.EnqueueCredit(ctx, payload)
   â†“
6. asynqQueue.EnqueueCredit()
   - Serialize payload â†’ JSON
   - Táº¡o asynq.Task vá»›i type "wallet:credit"
   - Set options (retry, timeout, queue)
   â†“
7. asynq.Client.Enqueue(task, opts)
   - Gá»­i job vÃ o Redis queue "wallet-credit"
   â†“
8. API tráº£ vá» 202 Accepted ngay láº­p tá»©c
   â†“
9. Worker (infra/queue/workers) nháº­n job tá»« Redis
   â†“
10. Worker xá»­ lÃ½:
    - Unmarshal payload
    - Gá»i CreditBalanceService.Execute()
    - Update balance trong transaction
    - Táº¡o transaction record
```

### Debit Flow (tÆ°Æ¡ng tá»±)

```
POST /wallet/debit
  â†“
queueClient.EnqueueDebit()
  â†“
Queue "wallet-debit"
  â†“
Worker xá»­ lÃ½ DebitBalanceService
```

---

## âš™ï¸ Cáº¥u HÃ¬nh

### Environment Variables

```bash
# Queue Provider (optional, default: "redis")
QUEUE_PROVIDER=redis  # Options: redis, rabbitmq, kafka, nats

# Redis Config (cho Asynq)
REDIS_ADDRESS=localhost:6379
REDIS_PASSWORD=
REDIS_DATABASE=0
```

### Queue Configuration

Má»—i job Ä‘Æ°á»£c enqueue vá»›i cÃ¡c options:

```go
opts := []asynq.Option{
    asynq.MaxRetry(3),           // Retry tá»‘i Ä‘a 3 láº§n
    asynq.Timeout(30 * time.Second),  // Timeout 30 giÃ¢y
    asynq.Queue(queueName),     // Queue name
}
```

**Queue Names:**
- `wallet-credit` - Cho credit operations
- `wallet-debit` - Cho debit operations

**Job Types:**
- `wallet:credit` - Credit job type
- `wallet:debit` - Debit job type

---

## âœ¨ TÃ­nh NÄƒng

### 1. Type-Safe API

Thay vÃ¬ generic `Enqueue(event, payload)`, cÃ³:
- `EnqueueCredit(payload)` - RÃµ rÃ ng má»¥c Ä‘Ã­ch
- `EnqueueDebit(payload)` - Type-safe

**Lá»£i Ã­ch:**
- âœ… Compile-time safety
- âœ… IDE autocomplete
- âœ… Dá»… Ä‘á»c vÃ  maintain

### 2. Duplicate Task Handling

```go
if errors.Is(err, asynq.ErrDuplicateTask) || errors.Is(err, asynq.ErrTaskIDConflict) {
    return nil  // Ignore duplicate, khÃ´ng fail
}
```

**Má»¥c Ä‘Ã­ch:** TrÃ¡nh fail khi client gá»­i duplicate requests (network retry, etc.)

### 3. Provider Abstraction

Há»— trá»£ nhiá»u queue providers:
- âœ… **Redis/Asynq** (implemented)
- â³ RabbitMQ (placeholder)
- â³ Kafka (placeholder)
- â³ NATS (placeholder)

Dá»… dÃ ng switch provider qua env var.

### 4. Automatic Serialization

Payload tá»± Ä‘á»™ng Ä‘Æ°á»£c serialize thÃ nh JSON:
```go
serializePayload(payload) â†’ []byte  // JSON format
```

**Error Handling:**
- Náº¿u marshal fail â†’ return error payload
- Worker sáº½ detect vÃ  reject job

### 5. Resource Management

```go
client.Close()  // ÄÃ³ng Asynq client connection
```

**LÆ°u Ã½:** Hiá»‡n táº¡i chÆ°a Ä‘Æ°á»£c gá»i trong graceful shutdown, nÃªn thÃªm vÃ o.

---

## ğŸ’¡ Best Practices

### 1. LuÃ´n Kiá»ƒm Tra Error

```go
if err := queueClient.EnqueueCredit(ctx, payload); err != nil {
    // Handle error:
    // - Log error
    // - Return 500 hoáº·c 503
    // - KhÃ´ng retry (Ä‘á»ƒ trÃ¡nh duplicate)
    return err
}
```

### 2. Sá»­ Dá»¥ng ReferenceID Cho Idempotency

```go
payload := queue.CreditJobPayload{
    UserID:      userID,
    Amount:      10000,
    ReferenceID: &referenceID,  // â† DÃ¹ng Ä‘á»ƒ Ä‘áº£m báº£o idempotency
    Metadata:    metadata,
}
```

**Lá»£i Ã­ch:**
- TrÃ¡nh duplicate processing
- CÃ³ thá»ƒ track job qua reference ID

### 3. Context Support

```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

err := queueClient.EnqueueCredit(ctx, payload)
```

**LÆ°u Ã½:** Hiá»‡n táº¡i client chÆ°a há»— trá»£ context timeout cho enqueue (Asynq cÃ³ há»— trá»£ nhÆ°ng chÆ°a dÃ¹ng).

### 4. Metadata Cho Audit

```go
payload := queue.CreditJobPayload{
    // ...
    Metadata: map[string]interface{}{
        "source": "api",
        "ip_address": c.ClientIP(),
        "request_id": requestID,
        "timestamp": time.Now().Unix(),
    },
}
```

### 5. Close Client Khi Shutdown

```go
// Trong main.go graceful shutdown
defer func() {
    if app.WalletHandler != nil {
        app.WalletHandler.CloseQueueClient()  // Cáº§n thÃªm method nÃ y
    }
}()
```

---

## ğŸ” Troubleshooting

### Issue 1: Job KhÃ´ng ÄÆ°á»£c Xá»­ LÃ½

**Triá»‡u chá»©ng:**
- API tráº£ vá» 202 Accepted
- NhÆ°ng worker khÃ´ng xá»­ lÃ½

**NguyÃªn nhÃ¢n:**
- Worker khÃ´ng cháº¡y
- Redis connection issues
- Queue name khÃ´ng khá»›p

**Giáº£i phÃ¡p:**
```bash
# 1. Kiá»ƒm tra worker
ps aux | grep worker

# 2. Kiá»ƒm tra Redis
redis-cli ping

# 3. Kiá»ƒm tra jobs trong queue
redis-cli
> LLEN asynq:wallet-credit
> LLEN asynq:wallet-debit

# 4. Xem Asynq monitor
make monitor
# Truy cáº­p: http://localhost:9090/monitor
```

### Issue 2: Duplicate Tasks

**Triá»‡u chá»©ng:**
- Nhiá»u transaction records giá»‘ng nhau

**NguyÃªn nhÃ¢n:**
- Client retry sau timeout
- KhÃ´ng dÃ¹ng ReferenceID

**Giáº£i phÃ¡p:**
```go
// LuÃ´n dÃ¹ng ReferenceID
referenceID := uuid.New().String()
payload.ReferenceID = &referenceID
```

### Issue 3: Serialization Error

**Triá»‡u chá»©ng:**
- Worker nháº­n payload vá»›i `{"error":"payload_marshal_failed"}`

**NguyÃªn nhÃ¢n:**
- Payload cÃ³ circular reference
- Payload cÃ³ type khÃ´ng marshal Ä‘Æ°á»£c

**Giáº£i phÃ¡p:**
- Kiá»ƒm tra payload structure
- Äáº£m báº£o táº¥t cáº£ fields cÃ³ JSON tags
- Test vá»›i `json.Marshal()` trÆ°á»›c

### Issue 4: Timeout Issues

**Triá»‡u chá»©ng:**
- Jobs bá»‹ timeout trÆ°á»›c khi xá»­ lÃ½ xong

**Giáº£i phÃ¡p:**
```go
// CÃ³ thá»ƒ tÄƒng timeout trong code (hiá»‡n táº¡i 30s)
opts := []asynq.Option{
    asynq.Timeout(60 * time.Second),  // TÄƒng lÃªn 60s
}
```

### Issue 5: Provider Not Implemented

**Triá»‡u chá»©ng:**
- Error: "queue provider X not implemented"

**NguyÃªn nhÃ¢n:**
- Set `QUEUE_PROVIDER` sang RabbitMQ/Kafka/NATS
- NhÆ°ng chÆ°a implement

**Giáº£i phÃ¡p:**
```bash
# Sá»­ dá»¥ng Redis (default)
unset QUEUE_PROVIDER
# hoáº·c
export QUEUE_PROVIDER=redis
```

---

## ğŸ”— LiÃªn Káº¿t Vá»›i Components KhÃ¡c

### Dependency Flow

```
cmd/api/wire.go
  â””â”€â†’ provideQueueClient()
       â””â”€â†’ queue/client.NewClient()
            â””â”€â†’ asynqQueue (implementation)
                 â””â”€â†’ Asynq Client
                      â””â”€â†’ Redis

internal/modules/wallet/interfaces/http/handler.go
  â””â”€â†’ WalletHandler
       â””â”€â†’ queueClient.EnqueueCredit/Debit()
            â””â”€â†’ (same flow as above)

infra/queue/workers/wallet.worker.go
  â””â”€â†’ Worker listens to:
       - "wallet:credit" jobs
       - "wallet:debit" jobs
       â””â”€â†’ Process via services
```

### Files LiÃªn Quan

- **`infra/queue/queue.constants.go`**: Job types, queue names, payload structs
- **`infra/queue/workers/wallet.worker.go`**: Worker xá»­ lÃ½ jobs
- **`cmd/api/wire.go`**: Dependency injection setup
- **`internal/modules/wallet/interfaces/http/handler.go`**: Sá»­ dá»¥ng client

---

## ğŸ“ VÃ­ Dá»¥ Code

### Example 1: Enqueue Credit vá»›i Metadata

```go
payload := queue.CreditJobPayload{
    UserID:      "user-123",
    Amount:      50000,
    ReferenceID: &referenceID,
    Metadata: map[string]interface{}{
        "source": "api",
        "payment_method": "bank_transfer",
        "bank_name": "Vietcombank",
        "transaction_id": "txn-abc-123",
    },
}

if err := queueClient.EnqueueCredit(ctx, payload); err != nil {
    log.Printf("Failed to enqueue credit: %v", err)
    return err
}

log.Printf("Credit job enqueued successfully")
```

### Example 2: Enqueue Debit vá»›i Error Handling

```go
payload := queue.DebitJobPayload{
    UserID:      userID,
    Amount:      amount,
    ReferenceID: &withdrawalID,
    Metadata: map[string]interface{}{
        "purpose": "withdrawal",
        "bank_account": "xxx-xxx-xxx",
    },
}

if err := queueClient.EnqueueDebit(ctx, payload); err != nil {
    // Check error type
    if strings.Contains(err.Error(), "connection") {
        return exception.ServiceUnavailable("Queue service unavailable")
    }
    return exception.InternalServerError("Failed to enqueue job")
}

// Success - job enqueued
```

### Example 3: Testing vá»›i Mock

```go
// In tests
type mockQueue struct {
    creditCalls []CreditJobPayload
    debitCalls  []DebitJobPayload
}

func (m *mockQueue) EnqueueCredit(ctx context.Context, payload interface{}) error {
    p := payload.(queue.CreditJobPayload)
    m.creditCalls = append(m.creditCalls, p)
    return nil
}

func (m *mockQueue) EnqueueDebit(ctx context.Context, payload interface{}) error {
    p := payload.(queue.DebitJobPayload)
    m.debitCalls = append(m.debitCalls, p)
    return nil
}

// Use in test
mockQueue := &mockQueue{}
client := &queueclient.Client{queue: mockQueue}
```

---

## ğŸ†š So SÃ¡nh Vá»›i Alternatives

### Option 1: DÃ¹ng Generic Queue Interface

**Hiá»‡n táº¡i (Typed):**
```go
queueClient.EnqueueCredit(ctx, payload)  // Type-safe
```

**Generic (Alternative):**
```go
queuePublisher.Publish(ctx, "wallet.credit", payload)  // Generic
```

**Trade-off:**
- âœ… Typed: An toÃ n hÆ¡n, rÃµ rÃ ng hÆ¡n
- âŒ Typed: Pháº£i táº¡o method má»›i cho má»—i job type
- âœ… Generic: Linh hoáº¡t hÆ¡n, Ã­t code hÆ¡n
- âŒ Generic: Dá»… sai job type, khÃ´ng cÃ³ compile-time check

**Káº¿t luáº­n:** Typed approach tá»‘t hÆ¡n cho wallet operations (critical operations).

### Option 2: DÃ¹ng Redis Client Trá»±c Tiáº¿p

**KhÃ´ng kháº£ thi vÃ¬:**
- Redis client chá»‰ lÃ m key-value
- KhÃ´ng cÃ³ job types, queues, retries
- Worker khÃ´ng thá»ƒ Ä‘á»c vÃ  xá»­ lÃ½

---

## ğŸ“ Design Decisions

### Táº¡i Sao DÃ¹ng Typed Methods?

1. **Type Safety**: Compile-time checking
2. **Clarity**: `EnqueueCredit()` rÃµ hÆ¡n `Enqueue("credit", ...)`
3. **Future-proof**: Dá»… thÃªm validation/transformation riÃªng cho má»—i type

### Táº¡i Sao DÃ¹ng Interface Abstraction?

1. **Testability**: Dá»… mock trong tests
2. **Flexibility**: Dá»… switch provider
3. **Separation of Concerns**: TÃ¡ch biá»‡t client vÃ  implementation

### Táº¡i Sao Xá»­ LÃ½ Duplicate Gracefully?

1. **Idempotency**: Äáº£m báº£o khÃ´ng xá»­ lÃ½ trÃ¹ng
2. **User Experience**: Network retry khÃ´ng fail request
3. **Reliability**: TrÃ¡nh lá»—i do race conditions

---

## ğŸ“š TÃ i Liá»‡u Tham Kháº£o

- [Asynq Documentation](https://github.com/hibiken/asynq)
- [Redis Queue Patterns](https://redis.io/docs/manual/patterns/distributed-queues/)
- [Idempotency Patterns](https://stripe.com/docs/api/idempotent_requests)

---

## â“ FAQ

**Q: Táº¡i sao khÃ´ng dÃ¹ng generic Queue interface tá»« `infra/queue`?**  
A: VÃ¬ wallet operations cáº§n typed API cho type safety vÃ  clarity. Generic interface tá»‘t cho events, nhÆ°ng wallet cáº§n specific methods.

**Q: CÃ³ thá»ƒ thÃªm job types khÃ¡c khÃ´ng?**  
A: CÃ³, nhÆ°ng cáº§n:
- ThÃªm method má»›i vÃ o `Queue` interface
- Implement trong `asynqQueue`
- ThÃªm job type constant trong `queue.constants.go`
- Update worker Ä‘á»ƒ handle job type má»›i

**Q: Táº¡i sao duplicate tasks return nil?**  
A: Äá»ƒ Ä‘áº£m báº£o idempotency. Náº¿u job Ä‘Ã£ tá»“n táº¡i, khÃ´ng cáº§n enqueue láº¡i (Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½ hoáº·c Ä‘ang xá»­ lÃ½).

**Q: CÃ³ thá»ƒ thay Ä‘á»•i retry count khÃ´ng?**  
A: CÃ³, sá»­a trong code:
```go
asynq.MaxRetry(5)  // Thay Ä‘á»•i tá»« 3 â†’ 5
```

**Q: Worker vÃ  Client cÃ³ dÃ¹ng cÃ¹ng Redis connection khÃ´ng?**  
A: CÃ³ thá»ƒ dÃ¹ng cÃ¹ng Redis instance, nhÆ°ng khÃ¡c connections (client vÃ  worker lÃ  2 processes riÃªng).

---

**TÃ i liá»‡u nÃ y Ä‘Æ°á»£c táº¡o bá»Ÿi: Ludo Backend Team**  
**PhiÃªn báº£n: 1.0**  
**Cáº­p nháº­t: 2024**

